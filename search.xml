<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CSS_Loader]]></title>
    <url>%2F2020%2F02%2F28%2FCSS-Loader-1%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS Loader]]></title>
    <url>%2F2020%2F02%2F28%2FCSS-Loader%2F</url>
    <content type="text"><![CDATA[如何透過Webpakc去讀取非JS的檔案，如CSS、HTML、Images…loader Loader 讀取解析除了JS以外的檔案 讀取順序都是由後面執行到前面的，ex: [‘style-loader(第二)’, ‘css-loader (先)’] Module: 是用來提取非js會用到的功能 用webpack讀取、運用CSS 以下分成拆分出CSS與注入JS兩種方式 注入JS Step 1: 安裝 CSS-Loader 和 Style-Loader 1npm install --save-dev css-loader style-loader Step 2: 建立css 檔案, 且於index.js載入 1import './index.css'; Step 3: 設定webpack.config.js 123456module: { rules: [{ test: /\.css$/, use: ['style-loader', 'css-loader'] // css-loader 讀去css / style-loader 注入JS }] } 拆分CSS 想將CSS獨立出來時，就需要使用Plugin.什麼是plugin, 就是解決loader做不到的事情使用了plugin就不需要style-loader Step 1: extract-text-webpack-plugin 123npm install --save-dev extract-text-webpack-plugin@next!! webpack4 支援的版本目前是beta版，所以要加@next Step 2: extract-text-webpack-plugin 123456789101112131415161718192021// module.exports 前var ExtractTextPlugin = require('extract-text-webpack-plugin');var extractCSS = new ExtractTextPlugin('css/[name].css');// module.exports 裡module: { rules:[ ... { test: /\.css$/, // 讀取這個副檔名 use: extractCSS.extract([ 'css-loader', 'postcss-loader' ]) // Loader 的順序都是由後面執行到前面的, 所以會先使用css-loader, 再使用style-loader }, .. ]},plugins: [ extractCSS]]]></content>
      <categories>
        <category>前端學習</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>超越入門！Webpack 前端自動化開發</tag>
        <tag>loader</tag>
        <tag>CSS loader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[filename檔案名稱修正]]></title>
    <url>%2F2020%2F02%2F28%2Ffilename%E6%AA%94%E6%A1%88%E5%90%8D%E7%A8%B1%E4%BF%AE%E6%AD%A3%2F</url>
    <content type="text"><![CDATA[若有多個entry時，就將webpack.config裡的entry調整成object的形式 原先entry： 1entry: './index.js ’// 進入點 修改後entry： 12345entry: { // key: value index: ‘./index.js', about: ‘./about.js'}, 原先output 1234output: { path: path.resolve(__dirname, "./dist"), filename: 'index-bundle.js’} 修改後output 123456!!![name] =>> 依照entry的key的名稱output: { path: path.resolve(__dirname, "./dist"), filename: '[name]-bundle.js’}]]></content>
      <categories>
        <category>前端學習</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>超越入門！Webpack 前端自動化開發</tag>
        <tag>filename</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用NODE_ENV]]></title>
    <url>%2F2020%2F02%2F21%2F%E4%BD%BF%E7%94%A8NODE-ENV%2F</url>
    <content type="text"><![CDATA[process.env 官方The process.env property returns an object containing the user environment NODE_ENV Node.js 裡的環境變數，用來知道目前的執行環境為何不同環境(deploy / develop)時，執行的內容可能有所差異，也因此可以用環境變數來做判斷 實作package.json1234"scripts": { "start": "cross-env NODE_ENV=development webpack --mode development", "deploy": "cross-env NODE_ENV=development webpack --mode production"} 環境設定調整 可以在config中，用NODE_ENV去判斷執行的內容If (NODE_ENV === ‘development’) {} 可以在config中，用NODE_ENV去當mode的參數，省去在script中 –mode development 1234module.exports = { mode: process.env.NODE_ENV, ...} 注意Windows 要額外安裝cross-env，因其沒有NODE_ENV環境變數]]></content>
      <categories>
        <category>前端學習</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>超越入門！Webpack 前端自動化開發</tag>
        <tag>NODE_ENV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在陣列中搜尋值、索引值？]]></title>
    <url>%2F2020%2F02%2F15%2F%E5%A6%82%E4%BD%95%E5%9C%A8%E9%99%A3%E5%88%97%E4%B8%AD%E6%90%9C%E5%B0%8B%E5%80%BC%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[在JavaScript中，有諸多的方法用以找尋特定的值、位置，以下整理在陣列中搜尋時，可能會用到的方法其中所列的方法為：includes、find、findIndex、indexOf及filter includes 判斷陣列是否包含特定的元素，並以此來回傳 Boolean (true /false)arr.includes(searchElement[, fromIndex]) 123const arr = [1, 2, 3];console.log(arr.includes(2, [fromIndex])) // trueconsole.log(arr.includes('2', [fromIndex])) // false find 回傳第一個滿足所提供之測試函式的元素”值”，否則回傳 undefined 12345const arr = [5, 12, 8, 130, 44];const found = arr.find(element => element == 10);console.log(found); findIndex 回傳第一個滿足所提供之函式的”索引”，否則回傳 -1 12345const arr = [5, 12, 8, 130, 44];const found = arr.findIndex(element => element == 10);console.log(found); indexOf 回傳陣列中第一個被找到之”索引”，否則回傳 -1arr.indexOf(searchElement[, fromIndex]) 123const beasts = ['ant', 'bison', 'camel', 'duck', 'bison'];console.log(beasts.indexOf('bison')); filter 會建立一個經指定之函式運算後，由「原陣列」中通過該函式檢驗之元素所構成的「新陣列」 123const words = ["spray", "limit", "elite", "exuberant", "destruction", "present", "happy"];let longWords = words.filter(word => word.length > 6); 用途 用途 陣列方法 確認是否存在？ includes 需要取得值 find、filter 需要取得索引值 findIndex、indexof]]></content>
      <categories>
        <category>前端學習</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Search data</tag>
        <tag>Array&#39;s methods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Path檔案路徑設定]]></title>
    <url>%2F2020%2F02%2F14%2FPath%E6%AA%94%E6%A1%88%E8%B7%AF%E5%BE%91%E8%A8%AD%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[開發時，往往都有一個src的資料夾，裡面放的都是未經編譯的開發檔案且通常不會將預處理檔案與webpack放在同一個階層 使用webpack編譯時，將打包後的資料放進預設dist裡又今日檔案階層不同、資料夾來源不同等等… 就要進行路徑調整 重點：以下兩個分別是node.js的方法與環境變數path.resolve() path是node.js用來處理跟“路徑”有關的方法，方會用到的API resolve是用來將相對路徑或路徑片段解析成絕對路徑 webpack官方推推的方法 __dirname 前方有兩個底線，其為node.js的全域環境變數 指的是當前執行文件所在目錄位置 實作調整路徑 Step1: 用require 的語法將node.js 環境裡面的path方法拿進webpack裡面使用 1var path = require("path"); Step2: 用context來指定entry的資料夾 12345678module.exports = { context: path.resolve(__dirname, "./src”), // path.resolve(當前目錄位置, 指派的相對路徑) => 系統絕對路徑 entry: './index.js', // 進入點 output: { path: path.resolve(__dirname, "./dist"), filename: 'index-bundle.js' }} Step3: 將編譯後的檔案放置指定資料夾 12345678module.exports = { context: path.resolve(__dirname, "./src”), // path.resolve(當前目錄位置, 指派的相對路徑) => 系統絕對路徑 entry: './index.js', // 進入點 output: { path: path.resolve(__dirname, "./dist"), filename: 'index-bundle.js' }}]]></content>
      <categories>
        <category>前端學習</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>path</tag>
        <tag>超越入門！Webpack 前端自動化開發</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本webpack啟動與設定]]></title>
    <url>%2F2020%2F02%2F14%2F%E5%9F%BA%E6%9C%ACwebpack%E5%95%9F%E5%8B%95%E8%88%87%E8%A8%AD%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[webpack自動化開發工具有很多新的加速開發前端技術，例如vue、stylus、sass… ,但這些技術在沒有用特定工具轉換、編譯前，瀏覽器是看不懂的，而這個工具就是 Webpackwebpack將這些語言轉換成瀏覽器看得懂的HTML、CSS、JavaScript甚至可以用webpack來壓縮圖片下列條列基本webpack啟動與設定… Step1: npm init Step2: npm install webpack webpack-cli –save -dev Step3: 新增一個webpack.config.js 123456module.exports = { entry: './index.js', // 進入點 output: { filename: 'index-bundle.js' }} 用webpack開發網站的時候，所有東西都要用模組化來製作包括 webpack 裡的config也要模組化 module.exports =>>> 我要將模組丟出去拉 Step4: 於package.json加入以下片段 123"scripts": { “start”: “webpack"} Step5: 於終端機啟動 npm run start 新版的的webpack, 一定要透過npm scripts去執行webpack, 而非直接打webpack 執行webpack, 也做了轉換跟打包 沒有特別設定，會將檔案放置預設的dist資料夾 Q: 單純設定上述的時候，會發生以下錯誤，如何解決這個Warning? WARNING in configuration The 'mode' option has not been set, webpack will fallback to 'production' for this value. Set 'mode' option to 'development' or 'production' to enable defaults for each environment. You can also set it to 'none' to disable any default behavior. Learn more: https://webpack.js.org/configuration/mode/ A1. [👎] 直接在config 加入 mode 1234module.exports = { mode: "production", ...} A2. [👍] 於package.json 調整script 1234567..."scripts": { "start": "webpack --mode development", "deploy": "webpack --mode production"},...]]></content>
      <categories>
        <category>前端學習</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>超越入門！Webpack 前端自動化開發</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax、CORS - 整理與小應用]]></title>
    <url>%2F2020%2F02%2F11%2F%E6%95%B4%E7%90%86%E8%88%87%E5%B0%8F%E6%87%89%E7%94%A8%2F</url>
    <content type="text"><![CDATA[❓Ajax是什麼 (Asynchronous JavaScript and XML)MDN入門篇 1. 2005 年時由 Jesse James Garrett 所發明的術語，描述一種使用數個既有技術的「新」方法 2. 使用 XMLHttpRequest物件來與伺服器進行通訊 3. 可以傳送並接收多種格式的資訊，包括 JSON、XML、HTML、以及文字檔案 4. 由於非同步的本質，代表可以與伺服溝通、交換資料、以及更新頁面，且“無須重整網頁” XMLHttpRequest XMLHttpRequest API 是 Ajax 的核心 透過 XMLHttpRequest 建立的請求，其取得資料的方式可以為非同步或同步兩種之一。 new XMLHttpRequest().open(方法, url, 是否非同步/預設非同步)12345678910111213141516171819202122232425262728(function() { var httpRequest; function makeRequest() { httpRequest = new XMLHttpRequest(); if (!httpRequest) { alert('Giving up :( Cannot create an XMLHTTP instance'); return false; } // 決定伺服器傳回資料後的處理方式 httpRequest.onreadystatechange = alertContents; // 決定處理方式之後你得確實發出 request，此時需叫用 HTTP request 類別的 open() 及 send() 方法 httpRequest.open('GET', 'test.html'); httpRequest.send(); } function alertContents() { if (httpRequest.readyState === XMLHttpRequest.DONE) { if (httpRequest.status === 200) { alert(httpRequest.responseText); } else { alert('There was a problem with the request.'); } } }})(); Fetch API 並非所有瀏覽器切支援，如舊ie, 故需要用polyfill去轉換 fetch 會使用 ES6 的 Promise 作回應 回傳的為 ReadableStream 物件，需要使用不同資料類型使用對應方法，才能正確取得資料物件MDN[OXXO]](https://www.oxxostudio.tw/articles/201908/js-fetch.html) 123456fetch(url, {}).then(function(response) { // 處理 response}).catch(function(err) { // 錯誤處理}); CORS基於安全性考量，程式碼所發出的“跨來源 HTTP“ 請求會受到限制。例如，XMLHttpRequest 及 Fetch 都遵守同源政策（same-origin policy）。這代表網路應用程式所使用的 API 除非使用 CORS 標頭，否則只能請求與應用程式相同網域的 HTTP 資源。 CORS解決辦法從Sever端下手, 可以串現成，如:heroku cors、自己做因為之前有碰過Google App Script的小經驗，所以這次也使用這方法．👉可參考達人做法 心得👉其實這次串接很幸運，看完環保署的網站提取URL後，竟然沒發生CORS.但…這樣不就沒練習到了嗎？？ 所以我只好去找別的同學的URL(app.js裡的cors_aqi), 然後再重走一遍 因為這個應用，也爬了很多文章和看別人的做法😀 AQI CodeView]]></content>
      <categories>
        <category>前端學習</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JS地下城</tag>
        <tag>Ajax</tag>
        <tag>CORS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聖誕節活動]]></title>
    <url>%2F2020%2F02%2F01%2F%E8%81%96%E8%AA%95%E7%AF%80%E6%B4%BB%E5%8B%95%2F</url>
    <content type="text"><![CDATA[💡 IDEA遲來的紀錄…聖誕節來臨前，想說找些友好的同事們一起玩玩交換禮物，但身為從事LINE串接服務的成員之一，總不能就名字寫在紙條就算了所以我跟同事們結合LINE BOT、設計師的UI圖、行銷組的文案、流程，完成了簡易的抽獎活動流程 …Github流程圖暨UI畫面··· ⌛ 流程 12/24活動前，先請大家報名，取得UID、名字 12/24活動當天，僅有報名的人，方能順利打開活動頁 點擊活動頁面抽獎地方，顯示被抽到的頭像 抽獎項與被抽到獎項的人，都會在收到推播訊息 已完成活動者，再次打開頁面，顯示獎項畫面 🍎 學習LIFFLINE官方出了新的LIFF 2.0，但一直沒有機會用到，想說就趁這個歡樂的小插曲來用用看吧LIFF是一個可以在 LINE App 內運作的 web app 平台; 1.0版本僅能在LINE手機端打開，不能在網頁上運作;但2.0版本後，網頁版也可以使用，而且在測試時也比較方便了． V2版本僅有Client API, 不像V1有Server API, 所以在建立LIFF上，不用自己打API創建，僅需要到Line developer後台建立．而且V2 也多了很多API, 例如可以查詢OS版本，這次我僅用GetProfile 用來取用戶uid和名字和SendMessage傳送中獎資訊, 希望之後可以用更多 團隊合作這次的專案我跟阿諾兩個人從吃飯閒聊開始，從討論、畫流程圖、請人出文案、出UI、寫API文件、寫程式….把它當做一個正式專案對待，只差沒有收錢、報價了吧:)但也賺到了寶貴經驗和特殊戰友情感． 🎁 REFV2 API 參考文件V2 GITHUB]]></content>
      <categories>
        <category>專案</category>
        <category>前端學習</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>LINE</tag>
        <tag>小專案</tag>
        <tag>遊戲活動</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[世界時鐘 - Date]]></title>
    <url>%2F2020%2F01%2F07%2F%E5%9C%B0%E4%B8%8B%E5%9F%8E4F-%E4%B8%96%E7%95%8C%E6%99%82%E9%90%98%2F</url>
    <content type="text"><![CDATA[Date.prototype.toLocaleString()MDN、w3schools對比上一關也有運用到此方法，這次因為各區域時間表示方法有差異，ex: 我在台灣，但我要顯示英文，所以我參考了文件，運用locales和options，再搭配Time Zone達成我的顯示目標 ···4F原始碼、4F畫面 Date() Date 物件是基於世界標準時間（UTC） 1970/1/1開始的毫秒數值來儲存時間。Date 物件只能由以 Date 作為建構子來產生 MDN 什麼是GMT？Greenwich Mean Time(GMT / 格林威治時間)格林威治標準時間的正午是指當平太陽橫穿格林威治子午線時（也就是在格林威治上空最高點時）的時間。 什麼是UTC?Coordinated Universal Time (UTC/ 世界協調時間).為了解決GMT時間流逝不均勻的問題，使用原子鐘來定義時間。 The difference between GMT and UTCGMT is am actual time zone, whereas UTC is a time standard that is used to keep time sync across the world TimeStamp時間戳記或稱為時間標記（英語：Timestamp）是指字符串或編碼訊息用於辨識記錄下來的時間日期。國際標準為ISO 8601。]]></content>
      <categories>
        <category>前端學習</category>
      </categories>
      <tags>
        <tag>JS地下城</tag>
        <tag>toLocaleString</tag>
        <tag>Date</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[toLocaleString / slice / substring]]></title>
    <url>%2F2020%2F01%2F06%2F%E5%9C%B0%E4%B8%8B%E5%9F%8E3F-%E8%A8%88%E7%AE%97%E6%A9%9F%2F</url>
    <content type="text"><![CDATA[地下城3F-計算機 :想說這任務應該不會太難吧(總是太天真)，但一但開始執行後，就會冒出好多好多問題使用哪種方式切版？ GRID使用哪種方式寫邏輯？ 就vue吧使用哪種計算機比較符合這樣的UI呈現？ IOS 計算機要如何輸入完後，取運算值和子來用？要如何三位一撇？以下來記錄這次的新收穫….. 基本邏輯 串連值(0-9 、00.)及運算子(+、-、x、/)至一個變數 點擊＝時，用regEp切分出運算子和值 ex: 1x2+2 => [1, 2, 2] [x, +] 先乘除後加減，藉由運算子的位置，得知數值位置，再搭配splice 移除再新增 123456let index = a.indexOf(items)while (index !== -1) { calculatorString.splice(index, 2, calculatorString[index] * calculatorString[index + 1]) calculatorOperators.splice(index, 1) index = calculatorOperators.indexOf(items)} 顯示最終剩下的數值至變數 Number.prototype.toLocaleString() 將這個方法用於此任務的三位一撇 numObj.toLocaleString([locales [, options]]) locales: 國家、區域的format options: 樣式（decimal(預設)、幣別、%、unit)、呈現等等..MDN String.prototype.slice() Method1::: Use to remove the last character from a string extracts a section of a string and returns it as a new string, without modifying the original string. str.slice([begin[, end]]) begin: 哪一個索引（起始為 0）開始提取。若是負的(ex: -3)，等於是str.length + beginIndex(-3) end: 提取值至其索引，不包含其本身,ex: (0, 2), 取0, 1。 負數概念如begin。MDN String.prototype.substring() Method2::: Use to remove the last character from a string returns the part of the string between the start and end indexes, or to the end of the string. str.substring(indexStart[, indexEnd]) indexStart: 第幾個索引開始（起始為 0）提取。 indexEnd[optional]: 至第幾個索引，其為不包含。若沒有寫則為至最後被包含MDN Differences between substring() and slice() 雖然slice和substring幾乎用起來一樣，但還是有些為的差異性 第一個值比第二個值大的時候：substring會調換起、迄值; 而slice會回空值 123let text = 'hsuifang'console.log(text.substring(5, 2)) // => "uif" console.log(text.slice(5, 2)) // => "" 當一或兩個值是負數或NaN: substring會皆視作是0; 而slice視NaN為0, 視負數為從字串最後面數回來 1234567## substringconsole.log(text.substring(-5, 2)) // => "hs"console.log(text.substring(-5, -2)) // => "" ## sliceconsole.log(text.slice(-5, 2)) // => ""console.log(text.slice(-5, -2)) // => "ifa"]]></content>
      <categories>
        <category>前端學習</category>
      </categories>
      <tags>
        <tag>JS地下城</tag>
        <tag>toLocaleString</tag>
        <tag>slice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Grid]]></title>
    <url>%2F2019%2F12%2F25%2F%E5%9C%B0%E4%B8%8B%E5%9F%8E1F-%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E6%B3%95%2F</url>
    <content type="text"><![CDATA[簡述我在這挑戰JS地下城1F-九九乘法中，使用陌生GRID以及HTML、CSS、JS將九九乘法表呈現出來去完成它．以下簡述GRID… 1F原始檔、1F DEMO 定義與特性 MDN定義：格線是一組水平線和垂直線的交叉集合：一個定義為行（row），另一個定義為列（column）。你可以讓各元素依照行列的規則放到各格線上一切都建立要從建立格線容器（grid container）開始 格線佈局具有以下特性 ::: 尺寸設定具有彈性 固定：pixel 靈活：百分比、fr(此單位為因grid產生) 單元佈置 使用行號、名字、目標區域，讓各單元放到精確的位置 Creation of additional tracks to hold content 控制對齊 使用z-index控制重疊內容 格線容器 元件要成為格線容器時，需要定義容器的顯示類型。宣告以後，該元素的所有直接子元素會變成格線單位（grid item）set to grid or inline-grid 123.grid-container { display: grid;} 格線軌道（Grid Track） 透過 grid-template-columns 與 grid-template-rows 屬性定義了行與列，也定義了格線軌道。定義的數量代表了多少區塊 ex: 1fr 1fr = 2個區塊 格線軌道定義的單位與方式 單位 - fr 、 ％、px 123456789101112131415161718192021Ａ. fr單位>> 代表格線容器內可用空間的分塊（fraction)、可用比例的概念去理解.grid-container { display: grid; grid-template-columns: 1fr 1fr 1fr; // 3個區塊}B. %>> 以區塊為100%, 去切分需要的百分比.grid-container { display: grid; grid-template-columns: 20% 30% 50%;}C. px.grid-container { display: grid; grid-template-columns: 100px 100px;} 單位可以混用 1234.grid-container { display: grid; grid-template-columns: 500px 1fr 2fr;} repeat(次數, 值) - 以迴圈表現 1234.wrapper { display: grid; grid-template-columns: repeat(3, 1fr);} 軌道縮放與 minmax()希望有高度一定，但又不要跑版的情境，可以用minmax() 12345.wrapper { display: grid; grid-template-columns: repeat(3, 1fr); grid-auto-rows: minmax(100px, auto);} 明式與暗式格線透過 grid-auto-rows 與 grid-auto-columns 屬性，給軌道定義一套大小。 12345.wrapper { display: grid; grid-template-columns: repeat(3, 1fr); grid-auto-rows: 200px;} 圖片來源：MDN Grid Lines Note!當我們定義一個格線(grid)，我們是定義一個區塊、一個grid track，而非線條、行．因為定義track 而產生 line Positioning items against lines（根據行、線定位項目） column => 由左線調至右線條，row => 由最上面線條至下方已 3 X 2 的 grid, column line 有4條， row line有3條，可參照圖片 grid-column-start grid-column-end grid-row-start grid-row-end grid-row (start / end) grid-column (start / end) grid-area (row-start / column-start / row-end / column-end)1234567891011.wrapper { display: grid; grid-template-columns: repeat(3, 1fr); grid-auto-rows: 100px; } .box1 { grid-column-start: 1; grid-column-end: 4; grid-row-start: 1; grid-row-end: 3; } Gutters Gutters between grid cells can be created using the 「 grid-column-gap」、 「grid-row-gap」、「grid-gap」Gutters 所指的為下方區塊與區塊間的黃色部分 1234567// 使用方式.wrapper { display: grid; grid-template-columns: repeat(3, 1fr); grid-column-gap: 10px; grid-row-gap: 1em;} memo 內容器的定位模式，與 flex 使用方式一樣。 ex: justify-self nesting :: grid 可以再grid]]></content>
      <categories>
        <category>前端學習</category>
      </categories>
      <tags>
        <tag>JS地下城</tag>
        <tag>CSS</tag>
        <tag>Grid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滾動捲軸的應用]]></title>
    <url>%2F2019%2F12%2F20%2F%E6%BB%BE%E5%8B%95%E6%8D%B2%E8%BB%B8%E7%9A%84%E6%87%89%E7%94%A8%2F</url>
    <content type="text"><![CDATA[|| 應用 How To Know I am at the very bottom side of document (用scroll 偵測到文件底部)document.body.offsetHeight = window.innerHeight + window.scrollY DOM Element offsetHeight The offsetHeight property returns the viewable height of an element in pixels, including padding, border and scrollbar, but not the margin. Window Property innerHeight Returns the height of the window's content area (viewport) including scrollbars innerWidth Returns the width of a window's content area (viewport) including scrollbars outerHeight Returns the height of the browser window, including toolbars/scrollbars outerWidth Returns the width of the browser window, including toolbars/scrollbars pageXOffset Returns the pixels the current document has been scrolled (horizontally) from the upper left corner of the window pageYOffset Returns the pixels the current document has been scrolled (vertically) from the upper left corner of the window scrollX An alias of pageXOffset scrollY An alias of pageYOffset Window Method scrollTo window.scrollTo(xpos, ypos) 滾動到特定位置, The scrollTo() method scrolls the document to the specified coordinates. scrollBy 滾動多少px, The scrollBy() method scrolls the document by the specified number of pixel]]></content>
      <categories>
        <category>前端學習</category>
      </categories>
      <tags>
        <tag>HTML DOM</tag>
        <tag>DOM Window</tag>
        <tag>DOM Element</tag>
        <tag>scroll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[箭頭函式與傳統函式差異]]></title>
    <url>%2F2019%2F12%2F14%2F%E7%AE%AD%E9%A0%AD%E5%87%BD%E5%BC%8F%E8%88%87%E5%82%B3%E7%B5%B1%E5%87%BD%E5%BC%8F%E5%B7%AE%E7%95%B0%2F</url>
    <content type="text"><![CDATA[arguments 參數 、This、建構式 A. 沒有arguments 參數123456789101112131415// # 1. 沒有arguments 參數// 將以下改成Arrow Function，並觀察差異const nums = function () { console.log(arguments) // argument 參數是屬於類陣列}const nums = () => { console.log(arguments) // Uncaught ReferenceError: arguments is not defined}// 若還是要取其餘參數const nums = (...arg) => { console.log(arg)} B. 沒有自己的This This 綁定的差異箭頭函式沒有自己的This也無法透過 call, apply, bind 重新給予this 123456789101112131415161718192021222324252627var myName = '全域'var person = { myName: '小明', callName: function () { console.log('1', this.myName) // 1 小明 setTimeout(function() { console.log('2', this.myName) // 2 全域 }, 0) }, // 箭頭函式沒有自己的This, this 指向外層 callArrowName: function () { console.log('3', this.myName) // 3 小明 setTimeout(() => { console.log('4', this.myName) // 4 小明 }, 0) }, // 箭頭函式沒有自己的This, this 指向外層 callArrowName2 : () => { console.log('5', this.myName) // 5 全域 setTimeout(() => { console.log('6', this.myName) // 6 全域 }, 0) } }person.callName()person.callArrowName()person.callArrowName2() 箭頭函式是「無法」做建構函式使用1234567891011121314const Fn = function (a) { this.name = a}const ArrowFn = (a) => { this.name = a;}console.log(Fn.prototype, ArrowFn.prototype)// {constructor: ƒ} undefinedconst a = new Fn('a')console.log(a) //Fn {name: "a"}const b = new ArrowFn('b’) // ArrowFn is not a constructor]]></content>
      <categories>
        <category>前端學習</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>六角學院</tag>
        <tag>arrowFunction</tag>
        <tag>箭頭函式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this]]></title>
    <url>%2F2019%2F12%2F10%2Fthis%2F</url>
    <content type="text"><![CDATA[“THIS” 執行函式的時候就會產生，他是一個關鍵字 每個執行環境都有屬於自己的this 關鍵字 this它的指向跟我們怎麼「定義」它沒有關係 this 與函式如何宣告、建立沒有關聯性，僅與 「呼叫方法/執行」有關 || this 的調用方式A. 物件的方法調用 (最常見的形式) this 與函式如何宣告沒有關聯性，僅與呼叫方法有關物件的方法調用時，僅需要關注是在哪一個物件下呼叫 1234567891011var myName = '真心鎮大冒險'function callName () { console.log(this, this.myName)}var family = { myName: '小明家', callName: callName}family.callName() // {myName: "小明家", callName: ƒ} "小明家" B. 簡易呼叫 直接調用都是屬於simple Code, ex:: closure 、IIFE、callbackSimple Code this 指向全域, 但如果在嚴格模式下就會顯示undefined C. call, apply, Bind 方法!參考 12345678910111213141516171819202122var myName = '真心鎮大冒險'var family = { myName: '小明家'}function fn(para1, para2) { console.log(this, para1, para2)}// 第一個是帶入this物件// call 立刻執行// {myName: "小明家"} 1 2fn.call(family, 1, 2)// 帶入參數的方法用“”陣列// {myName: "小明家"} 2 3fn.apply(family, [2, 3]) // 不會立刻執行// 可以帶入部分參數// {myName: "小明家"} "JJ" “LL"var fn2 = fn.bind(family, 'JJ', 'LL’) fn2() D. NewE. DOM事件處理器 1 2 3 4 press Btn // this 是綁定 button 本身 &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;button onclick=&quot;console.dir(this)&quot;&gt;press Btn&lt;/button&gt; &lt;script&gt; var fn = function () { console.dir(this) this.style.backgroundColor = &apos;orange&apos; } var els = document.querySelectorAll(&apos;li&apos;) for (var i = 0; i &lt; els.length; i++) { els[i].addEventListener(&apos;click&apos;, fn) } &lt;/script&gt; F. 箭頭函式]]></content>
      <categories>
        <category>前端學習</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>this</tag>
        <tag>六角學院</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Character Sets & Quantifiers]]></title>
    <url>%2F2019%2F09%2F26%2FRegExp2%2F</url>
    <content type="text"><![CDATA[! Content：Brackets []、Braces {}、Peratheses () Brackets [] - Character Sets With a “character class”, also called “character set”, you can tell the regex engine to match only one out of several characters. Simply place the characters you want to match between square brackets []. 參考來源 1234567re = /gr[ae]y/i => Must be an a or ere = /[GF]ray/ => Must be a G or Fre = /[^GF]ray/ => !! Match anything except a G or Fre = /[A-Z]ray/ => Match any Uppercase letterre = /[a-z]ray/ => Match any Lowercase letterre = /[A-Za-z]ray/ => Match any letterre = /[0-9]ray/ => Match any digit; ！！10ray符合 Curly Braces {} - Quantifiers curly braces are used by a quantifier with specific limits 12345// the following are three different limits of [ l ]re = /Hel{2}o/i => Must occur exactly {m} amount of timesre = /Hel{2,4}o/i // Must occur {m} amount of times based on numbersre = /Hel{2,}o/i // Must occur at least {m} times Peratheses () - Grouping12re = /([0-9]X){3}/ => 3 timesre = /^([0-9]X){3}$/]]></content>
      <categories>
        <category>前端學習</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>RegExp</tag>
        <tag>Modern JavaScript From The Beginning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RegExp - Metacharacter Symbols]]></title>
    <url>%2F2019%2F09%2F14%2FRegExp1%2F</url>
    <content type="text"><![CDATA[! Content： Metacharacters Symbols Metacharacters Symbols ^ => Caret means must start with$ => Must ends with, could matched with a word^$ => Must begin and end with. => Matches any ONE character* => Matches any character 0 or more times? => Optionals Charater\ => Escape character 小試身手區區區 12345678910111213141516171819202122232425262728let re;// Literal Charactersre = /hello/i// Metacharacters Symbolsre = /^h/i; // 一定要以一個h字母開頭(in re = /d$/i; // 一定要以一個d字母結尾(in insensitive)re = /^hello$/i // 只有hello才符合, hello開頭, hello結尾re = /h.llo$/i // h 和llo組合，之間需有一個字re = /h*llo$/i // 只要是h 和llo組合，不論之間有多少文字(0或1以上)re = /gre?a?y/i // gray和grey都符合re = /gre?a?y\?/i // 加了escapse 符號，?就會被當作一般?, 而非options character// String to matchconst str = 'h1llo';const result = re.exec(str)console.log(result)// Log Resultsfunction reTest(re, str) { if(re.test(str)) { console.log(`${str} matches ${re.source}`) } else { console.log(`${str} does not matched ${re.source}`) }}reTest(re, str)]]></content>
      <categories>
        <category>前端學習</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>RegExp</tag>
        <tag>Modern JavaScript From The Beginning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RegExp - Evaluation Functions]]></title>
    <url>%2F2019%2F09%2F11%2FRegExp%2F</url>
    <content type="text"><![CDATA[! Content： 正規表示式、可用的方法 正規表示式 A regular expression is an object that describes a pattern of characters.Regular expressions are used to perform pattern-matching and “search-and-replace” functions on text 首先先訂定一個pattern - /pattern/modifiers 123456789101112let re;re = /hello/re = /hello/i; // i = case insensitive/** modifier **/// i => case insensitive// g => Perform a global match(find all matches rather than stopping after the first match)// m => Perform multiline matchingconsole.log(re) // /hello/i;console.log(re.sourse) //hello 可以運用的方法exec() - Return result in an array or nullis used to retrieve the match of a regular expression in a string.這個pattern是否有在這個字串裡，有則回陣列，無則回null 1234const result = re.exec('hello world')console.log(result)// ["hello", index: 0, input: "hello world", groups: undefined]// index 是第幾個位置開始符合 test() - Return true or false 123const result = re.test('Hello')console.log(result)// true match() - Return result array or nullretrieves the specified value within a string or finds a match for one or more regular expressions.這個字串是否有符合這個pattern，有則回陣列，無則回null 1234const str = 'Hello There';const result = str.match(re)console.log(result)//["Hello", index: 0, input: "Hello There", groups: undefined] search() - Return index of the first match if not found return -1 1234const str = 'dd Hello There'const result = str.search(re)console.log(result)// 3 replace() - Return new string with some or all matchs of a pattern 1234const str = 'Hello There'const newStr = str.replace(re, 'Hi')console.log(newStr)// Hi There]]></content>
      <categories>
        <category>前端學習</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>RegExp</tag>
        <tag>Modern JavaScript From The Beginning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[波蘭文-購物篇]]></title>
    <url>%2F2019%2F08%2F28%2F%E6%B3%A2%E8%98%AD%E6%96%87-%E8%B3%BC%E7%89%A9%E7%AF%87%2F</url>
    <content type="text"><![CDATA[| 百貨公司(Centrum Handlowe)內的店家名稱 komputery 💻🖥 księgarnia - 書店 elektronika - 電器行 optyk - 🕶眼鏡行 odzież - 服飾店/ ubranie obuwie - 鞋墊 / buty apteka - 💊 sklep spożywczy - 食品店 kwiaciarnia - 花店 | 造句 W sklepie spożywczym kupujemy owoce i chleb. W księgarni kupujemy ksążki, atlasy i map. W sklepie obuwniczym kupujemy buty. W kwiaciarni kupujemy bukiety(花束), róże i tulipany. W sklepie z elektroniką kupujemy telewizory i termometr(溫度計). W sklepie komputerowym kupujemy komputery i dyskietki(磁碟片). W aptece kupujemy termometr. W salonie optycznym kupujemy okulary(眼鏡).]]></content>
      <categories>
        <category>波蘭文 | Mowić po polsku</category>
      </categories>
      <tags>
        <tag>HURRA! Po Polsku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[執行環境、作用域 (Jedna)]]></title>
    <url>%2F2019%2F08%2F26%2F%E5%9F%B7%E8%A1%8C%E7%92%B0%E5%A2%83%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[| JavaScript 如何運行JS是一個進直譯式語言, 透過直譯器 -> 直接運行，也因此若發生錯誤時, 會直接反映在環境中！！！以下為運行的過程 ::: 語法基本單元化 (Tokenizing)一個一個值先一一拆解 抽象結構樹 AST (Abstract Syntax Tree)分析結構，如圖: 代碼生成 produce小工具 | LHS、 RHS認識他們，當錯誤發生時，可以藉由錯誤資訊，提升排除錯誤的效率 Right-hand side (RHS 取值來自於右邊的變數上)123Ex: var ming = ‘小明'var man = mingconsole.log(ming) !! 若有發生錯誤時，會在執行過程中見之 Left-hand side (LHS 用來賦予值到左側的變數上)1Ex: var ming = 'ming' !! 若發生LHS錯誤的時候，需要去檢查是不是左邊的變數無法被賦予值 | 語法作用域(Lexical scope) 分為靜態作用域及動態作用域JavaScript 採取的為靜態作用域 靜態作用域變數的作用域在語法解析的時候，就已經決定作用域 動態作用域變數的作用域在函式調用時才決定]]></content>
      <categories>
        <category>前端學習</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>六角學院 - JavaScript 核心篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Moja plany na ten tydzień]]></title>
    <url>%2F2019%2F08%2F24%2Ftydzien%2F</url>
    <content type="text"><![CDATA[今天上波蘭文課時，Emilia老師介紹了一個免費、好用的波文學習工具 - hello Polish裡面有依據分級的對話內容、文章、mp3, 身為通勤族，真是個好東西！ >> 星期名字 / 使用該日時的說法 >> Dni tygodnia Kiedy (w + biernik) 1. poniedziałek w poniedziałek 2. wtorek we wtorek 3. środa w środę 4. czwartek w czwartek 5. piątek w piątek 6. sobota w sobotę 7. niedziela w niedzielę >> Słownictwo >> wolny - freeTo może wtorek? Jesteś wolna? początek - beginning mieć dużo pracy –Tego dnia mam zawsze dużo pracy. kończyć (kończę, kończysz) / skończyćKończę o 5 (piątej). Co ty na to? – How about that? mieć wizytę u lekarza - 跟醫生預約（一定使用這種用法）Mam wizytę u lekarza, a potem muszę pojechać do rodziców. zmęczony - tiredPo basenie(#6) zwykle jestem zmęczona. pasuje mi - it sounds fine for mePasuje mi sobota(主詞). podobnie - similarly sukienka - dress zajęty - busyJej koleżanka jest zajęta 來源: Hello Polish]]></content>
      <categories>
        <category>波蘭文 | Mowić po polsku</category>
      </categories>
      <tags>
        <tag>A1</tag>
        <tag>hellopolish.pl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[午餐約會]]></title>
    <url>%2F2019%2F08%2F22%2F%E5%8D%88%E9%A4%90%E7%B4%84%E6%9C%83%2F</url>
    <content type="text"><![CDATA[或許不久的將來會笑笑，就紀錄一下 今天主管打電話請場蟹約我跟另外一位同事中午聊聊會談的內容大約是釐清目前的工作項目、未來規劃等等 其中，也是促使我想書寫此篇的一個段落 主: OO你會想要寫、接觸後端嗎？(開始一連串描述…)同: 我覺得ＯＯ很可惜，雖然他懂的業務邏輯，但他不會後端程式及資料庫…..... 後來回程時，同事希望我想想要不要精進資料庫的能力因為他認爲很多頭頭都不太重視前端 但我也不停的想，或許他是對的，但以我現在還在追逐JS的階段真的適合現在這個時間點點其他領域的技能值嗎？ 只好慢慢看下去…]]></content>
      <categories>
        <category>東興路上</category>
      </categories>
      <tags>
        <tag>嘰嘰雜雜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gulp初探]]></title>
    <url>%2F2019%2F08%2F18%2FGulp%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[| 介紹gulp 官網 gulp是一個開源JavaScript工具包，由Eric Sc​​hoffstall創建，用作前端Web開發中的流構建系統。 它是一個基於Node.js和npm的任務運行器，用於自動化Web開發中涉及的耗時和重複性任務，如縮小，連接，緩存清除，單元測試，linting，優化等。 Gulp 四個基本API：： name discript gulp.task 執行任務 gulp.src 執行資料來源 gulp.dest 執行結果位置 gulp.watch 監視執行過程中，資料是否變更 操作事件使用pipe(), 其串接概念圖如下: | 安裝與Try It (mac經驗)STEP 1. 於terminal 輸入 sudo npm install gulp -g -g 安裝在目前的電腦上, 目的是啟用 “gulp” 這個指令當完成安裝時, 輸入gulp -v, 當terminal回應 command not found, 試著：輸入export PATH=$PATH:/Users/denis/.npm-global/bin STEP 2. 建立新檔案夾、npm init STEP 3. npm install gulp –save 裝在目前的專案資料夾內, 目的是執行 gulp 時可以取用的套件 STEP 4. 建立新檔案新增一個gulpfile.js 、source/ index.html STEP 5. 於gulpfile.js建立資料 1234567var gulp = require('gulp')// copyHTML 為自定義任務名稱gulp.task('copyHTML', function() { // 抓取source 裡的所有HTML return gulp.src('./source/**/*.html') .pipe(gulp.dest('./public/'))}) STEP 6. 於terminal執行Gulp 1gulp [任務名稱 ] ex: gulp copyHTML]]></content>
      <categories>
        <category>前端學習</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[網頁安全性驗證]]></title>
    <url>%2F2019%2F08%2F17%2F%E7%B6%B2%E9%A0%81%E5%AE%89%E5%85%A8%E6%80%A7%E9%A9%97%E8%AD%89%2F</url>
    <content type="text"><![CDATA[含有內容、ISSUE、解決方式、後記 || 專案內容使用者於LINE官方帳號點擊會員卡連結(API)，系統會進行LINE LOGIN 得知特定身份後，將UID置於連結，並導頁至會員卡網頁;而前端人員拿取UID打API取得會員卡資料。 || 專案ISSUE有位使用者複製LOGIN後的連結(含有UID資訊)，接著使用其他裝置點擊其連結，發現仍可以看到會員卡，故認為其有安全性的憂慮，且有違反歐洲的某的法規，因此要求改善。 || 解決方式 LINE LOGIN將Line 一次性的參數置入連結 前端人員取得連結參數, 打API再次驗證連結參數正確性 驗證成功後, Response Headers 多一個key 打API取會員卡資料時，Request Headers 多增加ㄧkey參數 若步驟2失敗時, 再走一次步驟1 || 後記 若之後其他使用者再複製此連結時，因為一次性參數原則，會再要求依據登入帳號密碼，執行LINE LOGIN驗證，也加強了安全性。 但這樣的一次性參數的安全性修正也苦了測試人員及開發人員，在手機端，因為是已登入APP狀態，所以不會要求輸入帳號密碼，也不會影響體驗 ; 但如果在網頁端，相關人員就要一直輸入帳號密碼或點擊確認輸入按鈕，嗚嗚嗚！]]></content>
      <categories>
        <category>專案</category>
      </categories>
      <tags>
        <tag>專案經驗</tag>
        <tag>安全性驗證</tag>
      </tags>
  </entry>
</search>
