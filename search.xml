<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[this]]></title>
    <url>%2F2019%2F12%2F10%2Fthis%2F</url>
    <content type="text"><![CDATA[“THIS” 執行函式的時候就會產生，他是一個關鍵字 每個執行環境都有屬於自己的this 關鍵字 this它的指向跟我們怎麼「定義」它沒有關係 this 與函式如何宣告、建立沒有關聯性，僅與 「呼叫方法/執行」有關 || this 的調用方式A. 物件的方法調用 (最常見的形式) this 與函式如何宣告沒有關聯性，僅與呼叫方法有關物件的方法調用時，僅需要關注是在哪一個物件下呼叫 1234567891011var myName = '真心鎮大冒險'function callName () { console.log(this, this.myName)}var family = { myName: '小明家', callName: callName}family.callName() // {myName: "小明家", callName: ƒ} "小明家" B. 簡易呼叫 直接調用都是屬於simple Code, ex:: closure 、IIFE、callbackSimple Code this 指向全域, 但如果在嚴格模式下就會顯示undefined C. call, apply, Bind 方法!參考 12345678910111213141516171819202122var myName = '真心鎮大冒險'var family = { myName: '小明家'}function fn(para1, para2) { console.log(this, para1, para2)}// 第一個是帶入this物件// call 立刻執行// {myName: "小明家"} 1 2fn.call(family, 1, 2)// 帶入參數的方法用“”陣列// {myName: "小明家"} 2 3fn.apply(family, [2, 3]) // 不會立刻執行// 可以帶入部分參數// {myName: "小明家"} "JJ" “LL"var fn2 = fn.bind(family, 'JJ', 'LL’) fn2() D. NewE. DOM事件處理器 1 2 3 4 press Btn // this 是綁定 button 本身 &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;button onclick=&quot;console.dir(this)&quot;&gt;press Btn&lt;/button&gt; &lt;script&gt; var fn = function () { console.dir(this) this.style.backgroundColor = &apos;orange&apos; } var els = document.querySelectorAll(&apos;li&apos;) for (var i = 0; i &lt; els.length; i++) { els[i].addEventListener(&apos;click&apos;, fn) } &lt;/script&gt; F. 箭頭函式]]></content>
      <categories>
        <category>前端學習</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>this</tag>
        <tag>六角學院</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Character Sets & Quantifiers]]></title>
    <url>%2F2019%2F09%2F26%2FRegExp2%2F</url>
    <content type="text"><![CDATA[! Content：Brackets []、Braces {}、Peratheses () Brackets [] - Character Sets With a “character class”, also called “character set”, you can tell the regex engine to match only one out of several characters. Simply place the characters you want to match between square brackets []. 參考來源 1234567re = /gr[ae]y/i => Must be an a or ere = /[GF]ray/ => Must be a G or Fre = /[^GF]ray/ => !! Match anything except a G or Fre = /[A-Z]ray/ => Match any Uppercase letterre = /[a-z]ray/ => Match any Lowercase letterre = /[A-Za-z]ray/ => Match any letterre = /[0-9]ray/ => Match any digit; ！！10ray符合 Curly Braces {} - Quantifiers curly braces are used by a quantifier with specific limits 12345// the following are three different limits of [ l ]re = /Hel{2}o/i => Must occur exactly {m} amount of timesre = /Hel{2,4}o/i // Must occur {m} amount of times based on numbersre = /Hel{2,}o/i // Must occur at least {m} times Peratheses () - Grouping12re = /([0-9]X){3}/ => 3 timesre = /^([0-9]X){3}$/]]></content>
      <categories>
        <category>前端學習</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>RegExp</tag>
        <tag>Modern JavaScript From The Beginning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RegExp - Metacharacter Symbols]]></title>
    <url>%2F2019%2F09%2F14%2FRegExp1%2F</url>
    <content type="text"><![CDATA[! Content： Metacharacters Symbols Metacharacters Symbols ^ => Caret means must start with$ => Must ends with, could matched with a word^$ => Must begin and end with. => Matches any ONE character* => Matches any character 0 or more times? => Optionals Charater\ => Escape character 小試身手區區區 12345678910111213141516171819202122232425262728let re;// Literal Charactersre = /hello/i// Metacharacters Symbolsre = /^h/i; // 一定要以一個h字母開頭(in re = /d$/i; // 一定要以一個d字母結尾(in insensitive)re = /^hello$/i // 只有hello才符合, hello開頭, hello結尾re = /h.llo$/i // h 和llo組合，之間需有一個字re = /h*llo$/i // 只要是h 和llo組合，不論之間有多少文字(0或1以上)re = /gre?a?y/i // gray和grey都符合re = /gre?a?y\?/i // 加了escapse 符號，?就會被當作一般?, 而非options character// String to matchconst str = 'h1llo';const result = re.exec(str)console.log(result)// Log Resultsfunction reTest(re, str) { if(re.test(str)) { console.log(`${str} matches ${re.source}`) } else { console.log(`${str} does not matched ${re.source}`) }}reTest(re, str)]]></content>
      <categories>
        <category>前端學習</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>RegExp</tag>
        <tag>Modern JavaScript From The Beginning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RegExp - Evaluation Functions]]></title>
    <url>%2F2019%2F09%2F11%2FRegExp%2F</url>
    <content type="text"><![CDATA[! Content： 正規表示式、可用的方法 正規表示式 A regular expression is an object that describes a pattern of characters.Regular expressions are used to perform pattern-matching and “search-and-replace” functions on text 首先先訂定一個pattern - /pattern/modifiers 123456789101112let re;re = /hello/re = /hello/i; // i = case insensitive/** modifier **/// i => case insensitive// g => Perform a global match(find all matches rather than stopping after the first match)// m => Perform multiline matchingconsole.log(re) // /hello/i;console.log(re.sourse) //hello 可以運用的方法exec() - Return result in an array or nullis used to retrieve the match of a regular expression in a string.這個pattern是否有在這個字串裡，有則回陣列，無則回null 1234const result = re.exec('hello world')console.log(result)// ["hello", index: 0, input: "hello world", groups: undefined]// index 是第幾個位置開始符合 test() - Return true or false 123const result = re.test('Hello')console.log(result)// true match() - Return result array or nullretrieves the specified value within a string or finds a match for one or more regular expressions.這個字串是否有符合這個pattern，有則回陣列，無則回null 1234const str = 'Hello There';const result = str.match(re)console.log(result)//["Hello", index: 0, input: "Hello There", groups: undefined] search() - Return index of the first match if not found return -1 1234const str = 'dd Hello There'const result = str.search(re)console.log(result)// 3 replace() - Return new string with some or all matchs of a pattern 1234const str = 'Hello There'const newStr = str.replace(re, 'Hi')console.log(newStr)// Hi There]]></content>
      <categories>
        <category>前端學習</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>RegExp</tag>
        <tag>Modern JavaScript From The Beginning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[波蘭文-購物篇]]></title>
    <url>%2F2019%2F08%2F28%2F%E6%B3%A2%E8%98%AD%E6%96%87-%E8%B3%BC%E7%89%A9%E7%AF%87%2F</url>
    <content type="text"><![CDATA[| 百貨公司(Centrum Handlowe)內的店家名稱 komputery 💻🖥 księgarnia - 書店 elektronika - 電器行 optyk - 🕶眼鏡行 odzież - 服飾店/ ubranie obuwie - 鞋墊 / buty apteka - 💊 sklep spożywczy - 食品店 kwiaciarnia - 花店 | 造句 W sklepie spożywczym kupujemy owoce i chleb. W księgarni kupujemy ksążki, atlasy i map. W sklepie obuwniczym kupujemy buty. W kwiaciarni kupujemy bukiety(花束), róże i tulipany. W sklepie z elektroniką kupujemy telewizory i termometr(溫度計). W sklepie komputerowym kupujemy komputery i dyskietki(磁碟片). W aptece kupujemy termometr. W salonie optycznym kupujemy okulary(眼鏡).]]></content>
      <categories>
        <category>波蘭文 | Mowić po polsku</category>
      </categories>
      <tags>
        <tag>HURRA! Po Polsku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[執行環境、作用域 (Jedna)]]></title>
    <url>%2F2019%2F08%2F26%2F%E5%9F%B7%E8%A1%8C%E7%92%B0%E5%A2%83%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[| JavaScript 如何運行JS是一個進直譯式語言, 透過直譯器 -> 直接運行，也因此若發生錯誤時, 會直接反映在環境中！！！以下為運行的過程 ::: 語法基本單元化 (Tokenizing)一個一個值先一一拆解 抽象結構樹 AST (Abstract Syntax Tree)分析結構，如圖: 代碼生成 produce小工具 | LHS、 RHS認識他們，當錯誤發生時，可以藉由錯誤資訊，提升排除錯誤的效率 Right-hand side (RHS 取值來自於右邊的變數上)123Ex: var ming = ‘小明'var man = mingconsole.log(ming) !! 若有發生錯誤時，會在執行過程中見之 Left-hand side (LHS 用來賦予值到左側的變數上)1Ex: var ming = 'ming' !! 若發生LHS錯誤的時候，需要去檢查是不是左邊的變數無法被賦予值 | 語法作用域(Lexical scope) 分為靜態作用域及動態作用域JavaScript 採取的為靜態作用域 靜態作用域變數的作用域在語法解析的時候，就已經決定作用域 動態作用域變數的作用域在函式調用時才決定]]></content>
      <categories>
        <category>前端學習</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>六角學院 - JavaScript 核心篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Moja plany na ten tydzień]]></title>
    <url>%2F2019%2F08%2F24%2Ftydzien%2F</url>
    <content type="text"><![CDATA[今天上波蘭文課時，Emilia老師介紹了一個免費、好用的波文學習工具 - hello Polish裡面有依據分級的對話內容、文章、mp3, 身為通勤族，真是個好東西！ >> 星期名字 / 使用該日時的說法 >> Dni tygodnia Kiedy (w + biernik) 1. poniedziałek w poniedziałek 2. wtorek we wtorek 3. środa w środę 4. czwartek w czwartek 5. piątek w piątek 6. sobota w sobotę 7. niedziela w niedzielę >> Słownictwo >> wolny - freeTo może wtorek? Jesteś wolna? początek - beginning mieć dużo pracy –Tego dnia mam zawsze dużo pracy. kończyć (kończę, kończysz) / skończyćKończę o 5 (piątej). Co ty na to? – How about that? mieć wizytę u lekarza - 跟醫生預約（一定使用這種用法）Mam wizytę u lekarza, a potem muszę pojechać do rodziców. zmęczony - tiredPo basenie(#6) zwykle jestem zmęczona. pasuje mi - it sounds fine for mePasuje mi sobota(主詞). podobnie - similarly sukienka - dress zajęty - busyJej koleżanka jest zajęta 來源: Hello Polish]]></content>
      <categories>
        <category>波蘭文 | Mowić po polsku</category>
      </categories>
      <tags>
        <tag>A1</tag>
        <tag>hellopolish.pl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[午餐約會]]></title>
    <url>%2F2019%2F08%2F22%2F%E5%8D%88%E9%A4%90%E7%B4%84%E6%9C%83%2F</url>
    <content type="text"><![CDATA[或許不久的將來會笑笑，就紀錄一下 今天主管打電話請場蟹約我跟另外一位同事中午聊聊會談的內容大約是釐清目前的工作項目、未來規劃等等 其中，也是促使我想書寫此篇的一個段落 主: OO你會想要寫、接觸後端嗎？(開始一連串描述…)同: 我覺得ＯＯ很可惜，雖然他懂的業務邏輯，但他不會後端程式及資料庫…..... 後來回程時，同事希望我想想要不要精進資料庫的能力因為他認爲很多頭頭都不太重視前端 但我也不停的想，或許他是對的，但以我現在還在追逐JS的階段真的適合現在這個時間點點其他領域的技能值嗎？ 只好慢慢看下去…]]></content>
      <categories>
        <category>東興路上</category>
      </categories>
      <tags>
        <tag>嘰嘰雜雜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gulp初探]]></title>
    <url>%2F2019%2F08%2F18%2FGulp%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[| 介紹gulp 官網 gulp是一個開源JavaScript工具包，由Eric Sc​​hoffstall創建，用作前端Web開發中的流構建系統。 它是一個基於Node.js和npm的任務運行器，用於自動化Web開發中涉及的耗時和重複性任務，如縮小，連接，緩存清除，單元測試，linting，優化等。 Gulp 四個基本API：： name discript gulp.task 執行任務 gulp.src 執行資料來源 gulp.dest 執行結果位置 gulp.watch 監視執行過程中，資料是否變更 操作事件使用pipe(), 其串接概念圖如下: | 安裝與Try It (mac經驗)STEP 1. 於terminal 輸入 sudo npm install gulp -g -g 安裝在目前的電腦上, 目的是啟用 “gulp” 這個指令當完成安裝時, 輸入gulp -v, 當terminal回應 command not found, 試著：輸入export PATH=$PATH:/Users/denis/.npm-global/bin STEP 2. 建立新檔案夾、npm init STEP 3. npm install gulp –save 裝在目前的專案資料夾內, 目的是執行 gulp 時可以取用的套件 STEP 4. 建立新檔案新增一個gulpfile.js 、source/ index.html STEP 5. 於gulpfile.js建立資料 1234567var gulp = require('gulp')// copyHTML 為自定義任務名稱gulp.task('copyHTML', function() { // 抓取source 裡的所有HTML return gulp.src('./source/**/*.html') .pipe(gulp.dest('./public/'))}) STEP 6. 於terminal執行Gulp 1gulp [任務名稱 ] ex: gulp copyHTML]]></content>
      <categories>
        <category>前端學習</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[網頁安全性驗證]]></title>
    <url>%2F2019%2F08%2F17%2F%E7%B6%B2%E9%A0%81%E5%AE%89%E5%85%A8%E6%80%A7%E9%A9%97%E8%AD%89%2F</url>
    <content type="text"><![CDATA[含有內容、ISSUE、解決方式、後記 || 專案內容使用者於LINE官方帳號點擊會員卡連結(API)，系統會進行LINE LOGIN 得知特定身份後，將UID置於連結，並導頁至會員卡網頁;而前端人員拿取UID打API取得會員卡資料。 || 專案ISSUE有位使用者複製LOGIN後的連結(含有UID資訊)，接著使用其他裝置點擊其連結，發現仍可以看到會員卡，故認為其有安全性的憂慮，且有違反歐洲的某的法規，因此要求改善。 || 解決方式 LINE LOGIN將Line 一次性的參數置入連結 前端人員取得連結參數, 打API再次驗證連結參數正確性 驗證成功後, Response Headers 多一個key 打API取會員卡資料時，Request Headers 多增加ㄧkey參數 若步驟2失敗時, 再走一次步驟1 || 後記 若之後其他使用者再複製此連結時，因為一次性參數原則，會再要求依據登入帳號密碼，執行LINE LOGIN驗證，也加強了安全性。 但這樣的一次性參數的安全性修正也苦了測試人員及開發人員，在手機端，因為是已登入APP狀態，所以不會要求輸入帳號密碼，也不會影響體驗 ; 但如果在網頁端，相關人員就要一直輸入帳號密碼或點擊確認輸入按鈕，嗚嗚嗚！ 美廉社 SimpleMart 經驗紀錄]]></content>
      <categories>
        <category>專案</category>
      </categories>
      <tags>
        <tag>專案經驗</tag>
        <tag>安全性驗證</tag>
      </tags>
  </entry>
</search>
